<!DOCTYPE html>
<html class="no-js" lang="en">


<!-- Mirrored from doc.akka.io/docs/akka-http/current/implications-of-streaming-http-entity.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 01 Aug 2019 10:12:57 GMT -->
<head>
<title>Implications of the streaming nature of Request/Response Entities &bull; Akka HTTP</title>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<meta name="description" content="Akka Http: Modern, fast, asynchronous, streaming-first HTTP server and client."/>
<link rel="canonical" href="implications-of-streaming-http-entity.html"/>
<script type="text/javascript" src="lib/jquery/jquery.min.js"></script>
<script type="text/javascript" src="lib/foundation/dist/js/foundation.min.js"></script>
<link rel="stylesheet" type="text/css" href="lib/normalize.css/normalize.css"/>
<link rel="stylesheet" type="text/css" href="lib/foundation/dist/css/foundation.min.css"/>
<link rel="stylesheet" type="text/css" href="../../../../cdn.jsdelivr.net/docsearch.js/2/docsearch.min.css" />
<link rel="stylesheet" type="text/css" href="css/icons.css"/>
<link rel="stylesheet" type="text/css" href="css/page.css"/>
<link rel="shortcut icon" href="images/favicon.ico" />
<link rel="apple-touch-icon" sizes="180x180" href="images/apple-touch-icon.png"/>
<link rel="icon" type="image/png" sizes="32x32" href="images/favicon-32x32.png"/>
<link rel="icon" type="image/png" sizes="16x16" href="images/favicon-16x16.png"/>
<link rel="manifest" href="images/manifest.json"/>
<meta name="msapplication-TileImage" content="images/mstile-150x150.png"/>
<meta name="msapplication-TileColor" content="#15a9ce"/>
<meta name="theme-color" content="#15a9ce"/>
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"/>
<!-- OneTrust Cookies Consent Notice (Production Standard, akka.io, en-GB) start -->
<script src="../../../../optanon.blob.core.windows.net/consent/159bb13d-6748-4399-806e-ac28db879785.js" type="text/javascript" charset="UTF-8"></script>
<script type="text/javascript">
function OptanonWrapper() { }
</script>
<!-- OneTrust Cookies Consent Notice (Production Standard, akka.io, en-GB) end -->
<!--Google Analytics-->
<script type="text/plain" class="optanon-category-2">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-21117439-1']);
_gaq.push(['_setDomainName', 'akka.io']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})()
</script>
<script type="text/plain" class="optanon-category-2">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','../../../../www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-23127719-1', 'lightbend.com', {'allowLinker': true, 'name': 'tsTracker'});
ga('tsTracker.require', 'linker');
ga('tsTracker.linker:autoLink', ['lightbend.com','playframework.com','scala-lang.org','scaladays.org','spray.io','akka.io','scala-sbt.org','scala-ide.org']);
ga('tsTracker.send', 'pageview');
</script>
<!--Marketo-->
<script type="text/plain" class="optanon-category-3">
(function() {
var didInit = false;
function initMunchkin() {
if(didInit === false) {
didInit = true;
Munchkin.init('558-NCX-702', { 'asyncOnly': true, 'disableClickDelay': true });
}
}
var s = document.createElement('script');
s.type = 'text/javascript';
s.async = true;
s.src = '../../../../munchkin.marketo.net/munchkin.js';
s.onreadystatechange = function() {
if (this.readyState == 'complete' || this.readyState == 'loaded') {
initMunchkin();
}
};
s.onload = initMunchkin;
document.getElementsByTagName('head')[0].appendChild(s);
})();
</script>
</head>

<body id="underlay" data-toggler="nav-open">

<header class="site-header hide-for-large">
<div class="sticky-header clearfix">
<a href="https://akka.io/"><img class="logo" src="images/akka-logo-reverse.svg"/></a>

<button class="menu-icon float-right" type="button" data-toggle="underlay overlay"></button>
</div>
<div id="overlay" class="overlay-nav" data-toggler="nav-open">
<header class="nav-header">
<div class="nav-header-title">
<h1><a href="index-2.html">Akka HTTP</a></h1>
</div>
<div class="nav-header-version">
Version 10.1.9
</div>
<div class="nav-header-groups">
<select class="supergroup" name="Language"><option class="group" value="group-scala">Scala</option><option class="group" value="group-java">Java</option></select>
</div>
<div id="overlay-search-container" class="nav-header-search">
<input id="overlay-search" type="search" class="search" placeholder="Search"/>
</div>
</header>
<nav class="nav-toc">
<ul>
  <li><a href="security.html" class="page">! Security Announcements !</a></li>
  <li><a href="release-notes/index.html" class="page">0. Release Notes</a></li>
  <li><a href="introduction.html" class="page">1. Introduction</a></li>
  <li><a href="usage.html" class="page">2. Usage</a></li>
  <li><a href="common/index.html" class="page">3. Data Types &amp; Abstractions</a></li>
  <li><a href="server-side/index.html" class="page">4. Server API</a></li>
  <li><a href="client-side/index.html" class="page">5. Client API</a></li>
  <li><a href="extensions.html" class="page">6. Extensions</a></li>
  <li><a href="technologies.html" class="page">7. Supported Technologies</a></li>
  <li><a href="tipsandtricks.html" class="page">8. Tips And Tricks</a>
  <ul>
    <li><a href="handling-blocking-operations-in-akka-http-routes.html" class="page">Handling blocking operations in Akka HTTP</a></li>
    <li><a href="implications-of-streaming-http-entity.html#implications-of-the-streaming-nature-of-request-response-entities" class="active page">Implications of the streaming nature of Request/Response Entities</a>
    <ul>
      <li><a href="implications-of-streaming-http-entity.html#client-side-handling-of-streaming-http-entities" class="header">Client-Side handling of streaming HTTP Entities</a></li>
      <li><a href="implications-of-streaming-http-entity.html#server-side-handling-of-streaming-http-entities" class="header">Server-Side handling of streaming HTTP Entities</a></li>
    </ul></li>
    <li><a href="client-side/pool-overflow.html" class="page">Pool overflow and the max-open-requests setting</a></li>
  </ul></li>
  <li><a href="contributing.html" class="page">9. Contributing</a></li>
  <li><a href="reference.html" class="page">10. Reference</a></li>
</ul>
</nav>
</div>
</header>

<aside class="show-for-large">
<header class="nav-header fixed-sidebar-header">
<div class="nav-header-title">
<h1><a href="index-2.html">Akka HTTP</a></h1>
</div>
<div class="nav-header-version">
Version 10.1.9
</div>
<div class="nav-header-groups">
<select class="supergroup" name="Language"><option class="group" value="group-scala">Scala</option><option class="group" value="group-java">Java</option></select>
</div>
<div class="nav-header-search">
<input id="search" type="search" class="search" placeholder="Search"/>
</div>
</header>
<nav class="site-nav fixed-sidebar-contents">
<div class="nav-toc">
<ul>
  <li><a href="security.html" class="page">! Security Announcements !</a></li>
  <li><a href="release-notes/index.html" class="page">0. Release Notes</a></li>
  <li><a href="introduction.html" class="page">1. Introduction</a></li>
  <li><a href="usage.html" class="page">2. Usage</a></li>
  <li><a href="common/index.html" class="page">3. Data Types &amp; Abstractions</a></li>
  <li><a href="server-side/index.html" class="page">4. Server API</a></li>
  <li><a href="client-side/index.html" class="page">5. Client API</a></li>
  <li><a href="extensions.html" class="page">6. Extensions</a></li>
  <li><a href="technologies.html" class="page">7. Supported Technologies</a></li>
  <li><a href="tipsandtricks.html" class="page">8. Tips And Tricks</a>
  <ul>
    <li><a href="handling-blocking-operations-in-akka-http-routes.html" class="page">Handling blocking operations in Akka HTTP</a></li>
    <li><a href="implications-of-streaming-http-entity.html#implications-of-the-streaming-nature-of-request-response-entities" class="active page">Implications of the streaming nature of Request/Response Entities</a>
    <ul>
      <li><a href="implications-of-streaming-http-entity.html#client-side-handling-of-streaming-http-entities" class="header">Client-Side handling of streaming HTTP Entities</a></li>
      <li><a href="implications-of-streaming-http-entity.html#server-side-handling-of-streaming-http-entities" class="header">Server-Side handling of streaming HTTP Entities</a></li>
    </ul></li>
    <li><a href="client-side/pool-overflow.html" class="page">Pool overflow and the max-open-requests setting</a></li>
  </ul></li>
  <li><a href="contributing.html" class="page">9. Contributing</a></li>
  <li><a href="reference.html" class="page">10. Reference</a></li>
</ul>
</div>
</nav>
<footer class="nav-footer fixed-sidebar-footer">
<a href="https://akka.io/"><img class="logo" src="images/akka-logo-reverse.svg"/></a>

</footer>
</aside>

<main class="fixed-shift-for-large expanded row">
<section class="site-content small-12 column">

<article class="page-content row">
<div class="small-12 large-9 column" id="docs">
<h1><a href="#implications-of-the-streaming-nature-of-request-response-entities" name="implications-of-the-streaming-nature-of-request-response-entities" class="anchor"><span class="anchor-link"></span></a>Implications of the streaming nature of Request/Response Entities</h1>
<p>Akka HTTP is streaming <em>all the way through</em>, which means that the back-pressure mechanisms enabled by Akka Streams are exposed through all layersâ€“from the TCP layer, through the HTTP server, all the way up to the user-facing <span class="group-java"><a href="https://doc.akka.io/japi/akka-http/10.1.9/?akka/http/javadsl/model/HttpRequest.html">HttpRequest</a></span><span class="group-scala"><a href="https://doc.akka.io/api/akka-http/10.1.9/akka/http/scaladsl/model/HttpRequest.html">HttpRequest</a></span> and <span class="group-java"><a href="https://doc.akka.io/japi/akka-http/10.1.9/?akka/http/javadsl/model/HttpResponse.html">HttpResponse</a></span><span class="group-scala"><a href="https://doc.akka.io/api/akka-http/10.1.9/akka/http/scaladsl/model/HttpResponse.html">HttpResponse</a></span> and their <span class="group-java"><a href="https://doc.akka.io/japi/akka-http/10.1.9/?akka/http/javadsl/model/HttpEntity.html">HttpEntity</a></span><span class="group-scala"><a href="https://doc.akka.io/api/akka-http/10.1.9/akka/http/scaladsl/model/HttpEntity.html">HttpEntity</a></span> APIs.</p>
<p>This has surprising implications if you are used to non-streaming / not-reactive HTTP clients. Specifically it means that: &ldquo;<em>lack of consumption of the HTTP Entity, is signaled as back-pressure to the other side of the connection</em>&rdquo;. This is a feature, as it allows one only to consume the entity, and back-pressure servers/clients from overwhelming our application, possibly causing un-necessary buffering of the entity in memory.</p><div class="callout warning "><div class="callout-title">Warning</div>
<p>Consuming (or discarding) the Entity of a request is mandatory! If <em>accidentally</em> left neither consumed or discarded Akka HTTP will assume the incoming data should remain back-pressured, and will stall the incoming data via TCP back-pressure mechanisms. A client should consume the Entity regardless of the status of the <span class="group-java"><a href="https://doc.akka.io/japi/akka-http/10.1.9/?akka/http/javadsl/model/HttpResponse.html">HttpResponse</a></span><span class="group-scala"><a href="https://doc.akka.io/api/akka-http/10.1.9/akka/http/scaladsl/model/HttpResponse.html">HttpResponse</a></span>.</p></div>
<h2><a href="#client-side-handling-of-streaming-http-entities" name="client-side-handling-of-streaming-http-entities" class="anchor"><span class="anchor-link"></span></a>Client-Side handling of streaming HTTP Entities</h2>
<h3><a href="#consuming-the-http-response-entity-client-" name="consuming-the-http-response-entity-client-" class="anchor"><span class="anchor-link"></span></a>Consuming the HTTP Response Entity (Client)</h3>
<p>The most common use-case of course is consuming the response entity, which can be done via running the underlying <code>dataBytes</code> Source (or on the server-side using directives such as <code>BasicDirectives.extractDataBytes</code>).</p>
<p>It is encouraged to use various streaming techniques to utilise the underlying infrastructure to its fullest, for example by framing the incoming chunks, parsing them line-by-line and then connecting the flow into another destination Sink, such as a File or other Akka Streams connector:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka-http/tree/v10.1.9/docs/src/test/scala/docs/http/scaladsl/HttpClientExampleSpec.scala#L17-L37" target="_blank" title="Go to snippet source"></a><code class="language-scala">import java.io.File

import akka.actor.ActorSystem
import akka.http.scaladsl.model._
import akka.stream.ActorMaterializer
import akka.stream.scaladsl.{ FileIO, Framing }
import akka.util.ByteString

implicit val system = ActorSystem()
implicit val dispatcher = system.dispatcher
implicit val materializer = ActorMaterializer()

val response: HttpResponse = ???

response.entity.dataBytes
  .via(Framing.delimiter(ByteString(&quot;\n&quot;), maximumFrameLength = 256))
  .map(transformEachLine)
  .runWith(FileIO.toPath(new File(&quot;/tmp/example.out&quot;).toPath))

def transformEachLine(line: ByteString): ByteString = ???
</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka-http/tree/v10.1.9/docs/src/test/java/docs/http/javadsl/HttpClientExampleDocTest.java#L31-L79" target="_blank" title="Go to snippet source"></a><code class="language-java">import java.io.File;

import java.util.concurrent.TimeUnit;
import java.util.function.Function;
import akka.stream.ActorMaterializer;
import akka.stream.javadsl.Framing;
import akka.http.javadsl.model.*;
import scala.concurrent.duration.FiniteDuration;

final ActorSystem system = ActorSystem.create();
final ExecutionContextExecutor dispatcher = system.dispatcher();
final ActorMaterializer materializer = ActorMaterializer.create(system);

final HttpResponse response = responseFromSomewhere();

final Function&lt;ByteString, ByteString&gt; transformEachLine = line -&gt; line /* some transformation here */;

final int maximumFrameLength = 256;

response.entity().getDataBytes()
  .via(Framing.delimiter(ByteString.fromString(&quot;\n&quot;), maximumFrameLength, FramingTruncation.ALLOW))
  .map(transformEachLine::apply)
  .runWith(FileIO.toPath(new File(&quot;/tmp/example.out&quot;).toPath()), materializer);</code></pre></dd>
</dl>
<p>however sometimes the need may arise to consume the entire entity as <code>Strict</code> entity (which means that it is completely loaded into memory). Akka HTTP provides a special <span class="group-scala"><code>toStrict(timeout)</code></span><span class="group-java"><code>toStrict(timeout, materializer)</code></span> method which can be used to eagerly consume the entity and make it available in memory:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka-http/tree/v10.1.9/docs/src/test/scala/docs/http/scaladsl/HttpClientExampleSpec.scala#L43-L70" target="_blank" title="Go to snippet source"></a><code class="language-scala">import scala.concurrent.Future
import scala.concurrent.duration._

import akka.actor.ActorSystem
import akka.http.scaladsl.model._
import akka.stream.ActorMaterializer
import akka.util.ByteString

implicit val system = ActorSystem()
implicit val dispatcher = system.dispatcher
implicit val materializer = ActorMaterializer()

case class ExamplePerson(name: String)
def parse(line: ByteString): ExamplePerson = ???

val response: HttpResponse = ???

// toStrict to enforce all data be loaded into memory from the connection
val strictEntity: Future[HttpEntity.Strict] = response.entity.toStrict(3.seconds)

// while API remains the same to consume dataBytes, now they&#39;re in memory already:
val transformedData: Future[ExamplePerson] =
  strictEntity flatMap { e =&gt;
    e.dataBytes
      .runFold(ByteString.empty) { case (acc, b) =&gt; acc ++ b }
      .map(parse)
  }
</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka-http/tree/v10.1.9/docs/src/test/java/docs/http/javadsl/HttpClientExampleDocTest.java#L86-L113" target="_blank" title="Go to snippet source"></a><code class="language-java">final class ExamplePerson {
  final String name;
  public ExamplePerson(String name) { this.name = name; }
}

public ExamplePerson parse(ByteString line) {
  return new ExamplePerson(line.utf8String());
}

final ActorSystem system = ActorSystem.create();
final ExecutionContextExecutor dispatcher = system.dispatcher();
final ActorMaterializer materializer = ActorMaterializer.create(system);

final HttpResponse response = responseFromSomewhere();

// toStrict to enforce all data be loaded into memory from the connection
final CompletionStage&lt;HttpEntity.Strict&gt; strictEntity = response.entity()
    .toStrict(FiniteDuration.create(3, TimeUnit.SECONDS).toMillis(), materializer);

// while API remains the same to consume dataBytes, now they&#39;re in memory already:

final CompletionStage&lt;ExamplePerson&gt; person =
  strictEntity
    .thenCompose(strict -&gt;
      strict.getDataBytes()
        .runFold(emptyByteString(), (acc, b) -&gt; acc.concat(b), materializer)
        .thenApply(this::parse)
    );</code></pre></dd>
</dl>
<h3><a href="#integrating-with-akka-streams" name="integrating-with-akka-streams" class="anchor"><span class="anchor-link"></span></a>Integrating with Akka Streams</h3>
<p>In some cases, it is necessary to process the results of a series of Akka HTTP calls as Akka Streams. In order to ensure that the HTTP Response Entity is consumed in a timely manner, the Akka HTTP stream for each request must be executed and completely consumed, then sent along for further processing.</p>
<p>Failing to account for this behavior can result in seemingly non-deterministic failures due to complex interactions between http and stream buffering. This manifests as errors such as the following:</p>
<pre><code>Response entity was not subscribed after 1 second. Make sure to read the response entity body or call `discardBytes()` on it.
</code></pre>
<p>This error indicates that the http response has been available for too long without being consumed. It can be partially worked around by increasing the subscription timeout, but you will still run the risk of running into network level timeouts and could still exceed the timeout under load so it&rsquo;s best to resolve the issue properly such as in the examples below: </p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka-http/tree/v10.1.9/docs/src/test/scala/docs/http/scaladsl/HttpClientExampleSpec.scala#L76-L121" target="_blank" title="Go to snippet source"></a><code class="language-scala">import scala.concurrent.duration._
import scala.concurrent.Future

import akka.NotUsed
import akka.actor.ActorSystem
import akka.http.scaladsl.Http
import akka.http.scaladsl.model._
import akka.stream.ActorMaterializer
import akka.util.ByteString
import akka.stream.scaladsl.{ Flow, Sink, Source }

implicit val system = ActorSystem()
implicit val dispatcher = system.dispatcher
implicit val materializer = ActorMaterializer()

case class ExamplePerson(name: String)

def parse(line: ByteString): Option[ExamplePerson] =
  line.utf8String.split(&quot; &quot;).headOption.map(ExamplePerson)

val requests: Source[HttpRequest, NotUsed] = Source
  .fromIterator(() =&gt;
    Range(0, 10).map(i =&gt; HttpRequest(uri = Uri(s&quot;https://localhost/people/$i&quot;))).iterator
  )

val processorFlow: Flow[Option[ExamplePerson], Int, NotUsed] =
  Flow[Option[ExamplePerson]].map(_.map(_.name.length).getOrElse(0))

// Run and completely consume a single akka http request
def runRequest(req: HttpRequest): Future[Option[ExamplePerson]] =
  Http()
    .singleRequest(req)
    .flatMap { response =&gt;
      response.entity.dataBytes
        .runReduce(_ ++ _)
        .map(parse)
    }

// Run each akka http flow to completion, then continue processing. You&#39;ll want to tune the `parallelism`
// parameter to mapAsync -- higher values will create more cpu and memory load which may or may not positively
// impact performance.
requests
  .mapAsync(2)(runRequest)
  .via(processorFlow)
  .runWith(Sink.ignore)
</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka-http/tree/v10.1.9/docs/src/test/java/docs/http/javadsl/HttpClientExampleDocTest.java#L119-L153" target="_blank" title="Go to snippet source"></a><code class="language-java">final class ExamplePerson {
  final String name;
  public ExamplePerson(String name) { this.name = name; }
}

public ExamplePerson parse(ByteString line) {
  return new ExamplePerson(line.utf8String());
}

final ActorSystem system = ActorSystem.create();
final ExecutionContextExecutor dispatcher = system.dispatcher();
final ActorMaterializer materializer = ActorMaterializer.create(system);

// run a single request, consuming it completely in a single stream
public CompletionStage&lt;ExamplePerson&gt; runRequest(HttpRequest request) {
  return Http.get(system)
    .singleRequest(request)
    .thenCompose(response -&gt;
      response.entity().getDataBytes()
        .runReduce((a, b) -&gt; a.concat(b), materializer)
        .thenApply(this::parse)
    );
}

final List&lt;HttpRequest&gt; requests = new ArrayList&lt;&gt;();

final Flow&lt;ExamplePerson, Integer, NotUsed&gt; exampleProcessingFlow = Flow
        .fromFunction(person -&gt; person.toString().length());

final CompletionStage&lt;Done&gt; stream = Source
        .from(requests)
        .mapAsync(1, this::runRequest)
        .via(exampleProcessingFlow)
        .runWith(Sink.ignore(), materializer);
</code></pre></dd>
</dl>
<h3><a href="#discarding-the-http-response-entity-client-" name="discarding-the-http-response-entity-client-" class="anchor"><span class="anchor-link"></span></a>Discarding the HTTP Response Entity (Client)</h3>
<p>Sometimes when calling HTTP services we do not care about their response payload (e.g. all we care about is the response code), yet as explained above entity still has to be consumed in some way, otherwise we&rsquo;ll be exerting back-pressure on the underlying TCP connection.</p>
<p>The <code>discardEntityBytes</code> convenience method serves the purpose of easily discarding the entity if it has no purpose for us. It does so by piping the incoming bytes directly into an <code>Sink.ignore</code>.</p>
<p>The two snippets below are equivalent, and work the same way on the server-side for incoming HTTP Requests:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka-http/tree/v10.1.9/docs/src/test/scala/docs/http/scaladsl/HttpClientExampleSpec.scala#L127-L140" target="_blank" title="Go to snippet source"></a><code class="language-scala">import akka.actor.ActorSystem
import akka.http.scaladsl.model.HttpMessage.DiscardedEntity
import akka.http.scaladsl.model._
import akka.stream.ActorMaterializer

implicit val system = ActorSystem()
implicit val dispatcher = system.dispatcher
implicit val materializer = ActorMaterializer()

val response1: HttpResponse = ??? // obtained from an HTTP call (see examples below)

val discarded: DiscardedEntity = response1.discardEntityBytes()
discarded.future.onComplete { done =&gt; println(&quot;Entity discarded completely!&quot;) }
</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka-http/tree/v10.1.9/docs/src/test/java/docs/http/javadsl/HttpClientExampleDocTest.java#L159-L169" target="_blank" title="Go to snippet source"></a><code class="language-java">final ActorSystem system = ActorSystem.create();
final ExecutionContextExecutor dispatcher = system.dispatcher();
final ActorMaterializer materializer = ActorMaterializer.create(system);

final HttpResponse response = responseFromSomewhere();

final HttpMessage.DiscardedEntity discarded = response.discardEntityBytes(materializer);

discarded.completionStage().whenComplete((done, ex) -&gt; {
  System.out.println(&quot;Entity discarded completely!&quot;);
});</code></pre></dd>
</dl>
<p>Or the equivalent low-level code achieving the same result:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka-http/tree/v10.1.9/docs/src/test/scala/docs/http/scaladsl/HttpClientExampleSpec.scala#L157-L160" target="_blank" title="Go to snippet source"></a><code class="language-scala">val response1: HttpResponse = ??? // obtained from an HTTP call (see examples below)

val discardingComplete: Future[Done] = response1.entity.dataBytes.runWith(Sink.ignore)
discardingComplete.onComplete(done =&gt; println(&quot;Entity discarded completely!&quot;))</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka-http/tree/v10.1.9/docs/src/test/java/docs/http/javadsl/HttpClientExampleDocTest.java#L176-L186" target="_blank" title="Go to snippet source"></a><code class="language-java">final ActorSystem system = ActorSystem.create();
final ExecutionContextExecutor dispatcher = system.dispatcher();
final ActorMaterializer materializer = ActorMaterializer.create(system);

final HttpResponse response = responseFromSomewhere();

final CompletionStage&lt;Done&gt; discardingComplete = response.entity().getDataBytes().runWith(Sink.ignore(), materializer);

discardingComplete.whenComplete((done, ex) -&gt; {
  System.out.println(&quot;Entity discarded completely!&quot;);
});</code></pre></dd>
</dl>
<h2><a href="#server-side-handling-of-streaming-http-entities" name="server-side-handling-of-streaming-http-entities" class="anchor"><span class="anchor-link"></span></a>Server-Side handling of streaming HTTP Entities</h2>
<p>Similarly as with the Client-side, HTTP Entities are directly linked to Streams which are fed by the underlying TCP connection. Thus, if request entities remain not consumed, the server will back-pressure the connection, expecting that the user-code will eventually decide what to do with the incoming data.</p>
<p>Note that some directives force an implicit <code>toStrict</code> operation, such as <span class="group-scala"><code>entity(as[String])</code></span><span class="group-java"><code>entity(exampleUnmarshaller, example -&gt; {})</code></span> and similar ones.</p>
<h3><a href="#consuming-the-http-request-entity-server-" name="consuming-the-http-request-entity-server-" class="anchor"><span class="anchor-link"></span></a>Consuming the HTTP Request Entity (Server)</h3>
<p>The simplest way of consuming the incoming request entity is to simply transform it into an actual domain object, for example by using the <a href="routing-dsl/directives/marshalling-directives/entity.html">entity</a> directive:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka-http/tree/v10.1.9/docs/src/test/scala/docs/http/scaladsl/HttpServerExampleSpec.scala#L593-L617" target="_blank" title="Go to snippet source"></a><code class="language-scala">import akka.actor.ActorSystem
import akka.http.scaladsl.server.Directives._
import akka.http.scaladsl.marshallers.sprayjson.SprayJsonSupport._
import akka.stream.ActorMaterializer
import spray.json.DefaultJsonProtocol._

implicit val system = ActorSystem()
implicit val materializer = ActorMaterializer()
// needed for the future flatMap/onComplete in the end
implicit val executionContext = system.dispatcher

final case class Bid(userId: String, bid: Int)

// these are from spray-json
implicit val bidFormat = jsonFormat2(Bid)

val route =
  path(&quot;bid&quot;) {
    put {
      entity(as[Bid]) { bid =&gt;
        // incoming entity is fully consumed and converted into a Bid
        complete(&quot;The bid was: &quot; + bid)
      }
    }
  }</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka-http/tree/v10.1.9/docs/src/test/java/docs/http/javadsl/server/HttpServerExampleDocTest.java#L224-L247" target="_blank" title="Go to snippet source"></a><code class="language-java">class Bid {
  final String userId;
  final int bid;

  Bid(String userId, int bid) {
    this.userId = userId;
    this.bid = bid;
  }
}

final ActorSystem system = ActorSystem.create();
final ExecutionContextExecutor dispatcher = system.dispatcher();
final ActorMaterializer materializer = ActorMaterializer.create(system);

final Unmarshaller&lt;HttpEntity, Bid&gt; asBid = Jackson.unmarshaller(Bid.class);

final Route s = path(&quot;bid&quot;, () -&gt;
  put(() -&gt;
    entity(asBid, bid -&gt;
      // incoming entity is fully consumed and converted into a Bid
      complete(&quot;The bid was: &quot; + bid)
    )
  )
);</code></pre></dd>
</dl>
<p>Of course you can access the raw dataBytes as well and run the underlying stream, for example piping it into an FileIO Sink, that signals completion via a <span class="group-scala"><code>Future[IoResult]</code></span><span class="group-java"><code>CompletionStage&lt;IoResult&gt;</code></span> once all the data has been written into the file:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka-http/tree/v10.1.9/docs/src/test/scala/docs/http/scaladsl/HttpServerExampleSpec.scala#L623-L646" target="_blank" title="Go to snippet source"></a><code class="language-scala">import akka.actor.ActorSystem
import akka.stream.scaladsl.FileIO
import akka.http.scaladsl.server.Directives._
import akka.stream.ActorMaterializer
import java.io.File

implicit val system = ActorSystem()
implicit val materializer = ActorMaterializer()
// needed for the future flatMap/onComplete in the end
implicit val executionContext = system.dispatcher

val route =
  (put &amp; path(&quot;lines&quot;)) {
    withoutSizeLimit {
      extractDataBytes { bytes =&gt;
        val finishedWriting = bytes.runWith(FileIO.toPath(new File(&quot;/tmp/example.out&quot;).toPath))

        // we only want to respond once the incoming data has been handled:
        onComplete(finishedWriting) { ioResult =&gt;
          complete(&quot;Finished writing data: &quot; + ioResult)
        }
      }
    }
  }</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka-http/tree/v10.1.9/docs/src/test/java/docs/http/javadsl/server/HttpServerExampleDocTest.java#L253-L271" target="_blank" title="Go to snippet source"></a><code class="language-java">final ActorSystem system = ActorSystem.create();
final ExecutionContextExecutor dispatcher = system.dispatcher();
final ActorMaterializer materializer = ActorMaterializer.create(system);

final Route s =
  put(() -&gt;
    path(&quot;lines&quot;, () -&gt;
      withoutSizeLimit(() -&gt;
        extractDataBytes(bytes -&gt; {
          final CompletionStage&lt;IOResult&gt; res = bytes.runWith(FileIO.toPath(new File(&quot;/tmp/example.out&quot;).toPath()), materializer);

          return onComplete(() -&gt; res, ioResult -&gt;
            // we only want to respond once the incoming data has been handled:
            complete(&quot;Finished writing data :&quot; + ioResult));
        })
      )
    )
  );
</code></pre></dd>
</dl>
<h3><a href="#discarding-the-http-request-entity-server-" name="discarding-the-http-request-entity-server-" class="anchor"><span class="anchor-link"></span></a>Discarding the HTTP Request Entity (Server)</h3>
<p>Sometimes, depending on some validation (e.g. checking if given user is allowed to perform uploads or not) you may want to decide to discard the uploaded entity.</p>
<p>Please note that discarding means that the entire upload will proceed, even though you are not interested in the data being streamed to the server - this may be useful if you are simply not interested in the given entity, however you don&rsquo;t want to abort the entire connection (which we&rsquo;ll demonstrate as well), since there may be more requests pending on the same connection still.</p>
<p>In order to discard the databytes explicitly you can invoke the <code>discardEntityBytes</code> bytes of the incoming <code>HTTPRequest</code>:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka-http/tree/v10.1.9/docs/src/test/scala/docs/http/scaladsl/HttpServerExampleSpec.scala#L652-L674" target="_blank" title="Go to snippet source"></a><code class="language-scala">import akka.actor.ActorSystem
import akka.http.scaladsl.server.Directives._
import akka.stream.ActorMaterializer
import akka.http.scaladsl.model.HttpRequest

implicit val system = ActorSystem()
implicit val materializer = ActorMaterializer()
// needed for the future flatMap/onComplete in the end
implicit val executionContext = system.dispatcher

val route =
  (put &amp; path(&quot;lines&quot;)) {
    withoutSizeLimit {
      extractRequest { r: HttpRequest =&gt;
        val finishedWriting = r.discardEntityBytes().future

        // we only want to respond once the incoming data has been handled:
        onComplete(finishedWriting) { done =&gt;
          complete(&quot;Drained all data from connection... (&quot; + done + &quot;)&quot;)
        }
      }
    }
  }</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka-http/tree/v10.1.9/docs/src/test/java/docs/http/javadsl/server/HttpServerExampleDocTest.java#L277-L294" target="_blank" title="Go to snippet source"></a><code class="language-java">final ActorSystem system = ActorSystem.create();
final ExecutionContextExecutor dispatcher = system.dispatcher();
final ActorMaterializer materializer = ActorMaterializer.create(system);

final Route s =
  put(() -&gt;
    path(&quot;lines&quot;, () -&gt;
      withoutSizeLimit(() -&gt;
        extractRequest(r -&gt; {
          final CompletionStage&lt;Done&gt; res = r.discardEntityBytes(materializer).completionStage();

          return onComplete(() -&gt; res, done -&gt;
            // we only want to respond once the incoming data has been handled:
            complete(&quot;Finished writing data :&quot; + done));
        })
      )
    )
  );</code></pre></dd>
</dl>
<p>A related concept is <em>cancelling</em> the incoming <span class="group-scala"><code>entity.dataBytes</code></span><span class="group-java"><code>entity.getDataBytes()</code></span> stream, which results in Akka HTTP <em>abruptly closing the connection from the Client</em>. This may be useful when you detect that the given user should not be allowed to make any uploads at all, and you want to drop the connection (instead of reading and ignoring the incoming data). This can be done by attaching the incoming <span class="group-scala"><code>entity.dataBytes</code></span><span class="group-java"><code>entity.getDataBytes()</code></span> to a <code>Sink.cancelled()</code> which will cancel the entity stream, which in turn will cause the underlying connection to be shut-down by the server â€“ effectively hard-aborting the incoming request:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka-http/tree/v10.1.9/docs/src/test/scala/docs/http/scaladsl/HttpServerExampleSpec.scala#L680-L706" target="_blank" title="Go to snippet source"></a><code class="language-scala">import akka.actor.ActorSystem
import akka.stream.scaladsl.Sink
import akka.http.scaladsl.server.Directives._
import akka.http.scaladsl.model.headers.Connection
import akka.stream.ActorMaterializer

implicit val system = ActorSystem()
implicit val materializer = ActorMaterializer()
// needed for the future flatMap/onComplete in the end
implicit val executionContext = system.dispatcher

val route =
  (put &amp; path(&quot;lines&quot;)) {
    withoutSizeLimit {
      extractDataBytes { data =&gt;
        // Closing connections, method 1 (eager):
        // we deem this request as illegal, and close the connection right away:
        data.runWith(Sink.cancelled) // &quot;brutally&quot; closes the connection

        // Closing connections, method 2 (graceful):
        // consider draining connection and replying with `Connection: Close` header
        // if you want the client to close after this request/reply cycle instead:
        respondWithHeader(Connection(&quot;close&quot;))
        complete(StatusCodes.Forbidden -&gt; &quot;Not allowed!&quot;)
      }
    }
  }</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka-http/tree/v10.1.9/docs/src/test/java/docs/http/javadsl/server/HttpServerExampleDocTest.java#L300-L322" target="_blank" title="Go to snippet source"></a><code class="language-java">final ActorSystem system = ActorSystem.create();
final ExecutionContextExecutor dispatcher = system.dispatcher();
final ActorMaterializer materializer = ActorMaterializer.create(system);

final Route s =
  put(() -&gt;
    path(&quot;lines&quot;, () -&gt;
      withoutSizeLimit(() -&gt;
        extractDataBytes(bytes -&gt; {
          // Closing connections, method 1 (eager):
          // we deem this request as illegal, and close the connection right away:
          bytes.runWith(Sink.cancelled(), materializer);  // &quot;brutally&quot; closes the connection

          // Closing connections, method 2 (graceful):
          // consider draining connection and replying with `Connection: Close` header
          // if you want the client to close after this request/reply cycle instead:
          return respondWithHeader(Connection.create(&quot;close&quot;), () -&gt;
            complete(StatusCodes.FORBIDDEN, &quot;Not allowed!&quot;)
          );
        })
      )
    )
  );</code></pre></dd>
</dl>
<p>Closing connections is also explained in depth in the <a href="server-side/low-level-api.html#http-closing-connection-low-level">Closing a connection</a> section of the docs.</p>
<h3><a href="#pending-automatic-discarding-of-not-used-entities" name="pending-automatic-discarding-of-not-used-entities" class="anchor"><span class="anchor-link"></span></a>Pending: Automatic discarding of not used entities</h3>
<p>Under certain conditions it is possible to detect an entity is very unlikely to be used by the user for a given request, and issue warnings or discard the entity automatically. This advanced feature has not been implemented yet, see the below note and issues for further discussion and ideas.</p><div class="callout note "><div class="callout-title">Note</div>
<p>An advanced feature code named &ldquo;auto draining&rdquo; has been discussed and proposed for Akka HTTP, and we&rsquo;re hoping to implement or help the community implement it.</p>
<p>You can read more about it in <a href="https://github.com/akka/akka-http/issues/183">issue #183</a> as well as <a href="https://github.com/akka/akka-http/issues/117">issue #117</a> ; as always, contributions are very welcome!</p></div>
</div>
</article>

<div class="row">
<div class="small-12 large-9 column">
<section class="nav-prev-next row">
<div class="nav-prev small-6 column">
<a href="handling-blocking-operations-in-akka-http-routes.html"><i class="icon-prev"></i> <span class="link-prev">Handling blocking operations in Akka HTTP</span></a>
</div>
<div class="nav-next small-6 column clearfix">
<a class="float-right" href="client-side/pool-overflow.html">Pool overflow and the max-open-requests setting <i class="icon-next"></i></a>
</div>
</section>
</div>
</div>

<div class="source-github row">
Found an error in this documentation? The source code for this page can be found <a href="https://github.com/akka/akka-http/tree/v10.1.9/docs/src/main/paradox/implications-of-streaming-http-entity.md">here</a>.
Please feel free to edit and contribute a pull request.
</div>


<footer class="page-footer row clearfix">
<img class="akka-icon float-left show-for-medium" src="images/akka-icon.svg"/>
<section class="copyright">
<div>Akka HTTP is Open Source and available under the Apache 2 License.</div>
<p class="legal">
&copy; 2011-2019 <a href="https://www.lightbend.com/" target="_blank">Lightbend, Inc.</a> | 
<a href="https://www.lightbend.com/legal/licenses" target="_blank">Licenses</a> | 
<a href="https://www.lightbend.com/legal/terms" target="_blank">Terms</a> | 
<a href="https://www.lightbend.com/legal/privacy" target="_blank">Privacy Policy</a> | 
<a href="https://akka.io/cookie/" target="_blank">Cookie Listing</a> | 
<a class="optanon-toggle-display">Cookie Settings</a>
</p>
</section>
</footer>

</section>
</main>

<script type="text/javascript" src="js/scrollsneak.js"></script>
<script type="text/javascript">jQuery(document).foundation();</script>
<script type="text/javascript" src="js/groups.js"></script>
<script type="text/javascript" src="js/page.js"></script>
<script type="text/javascript" src="js/magellan.js"></script>

<style type="text/css">@import "lib/prettify/prettify.css";</style>
<script type="text/javascript" src="lib/prettify/prettify.js"></script>
<script type="text/javascript" src="lib/prettify/lang-scala.js"></script>
<script type="text/javascript">//<![CDATA[
jQuery(function(){window.prettyPrint && prettyPrint()});
//]]></script>
<!-- Algolia docs search -->
<script type="text/javascript" src="../../../../cdn.jsdelivr.net/docsearch.js/2/docsearch.min.js"></script>
<style>.algolia-autocomplete { display: block !important }</style>
<script type="text/javascript">
docsearch({
apiKey: '0ccbb8bf5148554a406fbf07df0a93b9',
indexName: 'akka-http',
inputSelector: '#search',
algoliaOptions: {
hitsPerPage: 5
}
});

docsearch({
apiKey: '0ccbb8bf5148554a406fbf07df0a93b9',
indexName: 'akka-http',
inputSelector: '#overlay-search',
algoliaOptions: {
hitsPerPage: 5
}
});

// set up "/" as global shortcut for focusing on search
jQuery(document).keypress(function (event) {
if (event.keyCode == 47) {
jQuery("#search").focus();
return false; // swallow key event, otherwise the / char would be input into the search box
}
});
</script>

<script type="text/javascript" src="assets/js/warnOldDocs.js"></script>


</body>

<!-- Mirrored from doc.akka.io/docs/akka-http/current/implications-of-streaming-http-entity.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 01 Aug 2019 10:12:57 GMT -->
</html>
